##### Simulation code for subgroup transportability
# codes for obtaining the balancing intercepts are borrowed from https://github.com/pzivich/publications-code/blob/master/ReBalancingIntercept/balance_intercept.R 

###########------- Libraries
library("mvtnorm")
library("tidyverse")
library("rootSolve")
library("Hmisc")
library("SciViews")
library("gam")
library("nnet")
library("boot")
library("dummy")
library("latex2exp")

###########------- Parameters specification
nsim=500
nGetTrue=10000
p=10
beta_coefs=matrix(rep(ln(1.05),p),byrow=F,nrow=1)      # coef of R model
xi_coefs=matrix(c(rep(ln(1.1),p/2),rep(ln(1.5),p/2)),byrow=F,nrow=1)      # coef of S model
zeta_coefs=matrix(c(rep(ln(1.1),p/2),rep(ln(1.5),p/2)),byrow=F,nrow=1)    # coef of S model
alpha_1=matrix(c(rep(1,p/2+1),rep(-1,p/2)),byrow=F,nrow=1)     # coef of A model
alpha_2=matrix(c(rep(1.5,p/2+1),rep(-1.5,p/2)),byrow=F,nrow=1)                                    # coef of A model
alpha_3=matrix(c(rep(2,p/2+1),rep(-2,p/2)),byrow=F,nrow=1)       # coef of A model
theta_0=c(1,2,rep(0.75,p-1))                        # coef of Y0 model

###########------- Data generation (for the use of both internal and external case)
Gen=function(n,n_m){
  ### Function to be solved - this function will be called to solve for intercepts in each data generation model
  tosolve <- function(ints, fxname, goalmarg){
    values <- fxname(ints)                          # simulated individual expected values at given intercept value
    if(is.null(dim(values))){                       # obtain mean of simulated individual expected values
      empmeans <-  mean(values)}else{
        empmeans <-  colMeans(values)
      }     
    diff = empmeans - goalmarg                      # difference from empirical mean to goal marginal distribution
    return(diff)                              
  }
  
  ## X
  X1_latent=rnorm(n,0,1)
  X1_sort=split(sort(X1_latent), sort(rep_len(1:9, length(X1_latent))))
  X1=as.factor(ifelse(X1_latent%in%X1_sort$`1` ,1,ifelse(X1_latent%in%c(X1_sort$`2`,X1_sort$`3`),2, ifelse(X1_latent%in%c(X1_sort$`4`,X1_sort$`5`,X1_sort$`6`),3, ifelse(X1_latent%in%c(X1_sort$`7`,X1_sort$`8`),4, 5)))))
  X1_1=ifelse(X1==1,1,0);X1_2=ifelse(X1==2,1,0);X1_3=ifelse(X1==3,1,0);X1_4=ifelse(X1==4,1,0);X1_5=ifelse(X1==5,1,0)
  sigma=matrix(rep(0.25,(p-1)*(p-1)),nrow=(p-1))
  diag(sigma)=0.5
  X2_10=rmvnorm(n, rep(0.1,p-1), sigma)
  X=matrix(cbind(X1, X2_10),byrow=F,ncol=p)
  
  ## R
  gen_pr_r <- function(beta0){
    prob_r <- plogis(as.numeric(beta0 + beta_coefs%*%t(X)) )  # probability generated by model at given intercept value
    return(prob_r)
  }
  goalmarg_r <- n_m/n
  rootr <- multiroot(f=tosolve, start=c(-1), fxname=gen_pr_r, goalmarg=goalmarg_r, atol=1e-12)$root # find root for R model
  R=rbinom(n, size=1, p=gen_pr_r(rootr))                     # simulate R using intercept solution
  
  ## S
  gen_pr_s <- function(xi_zeta0){
    odds <- matrix(nrow=length(R[R==1]), ncol=2)             # create empty matrix to store odds
    odds[,1] <- exp(xi_zeta0[1] + xi_coefs%*%t(X[R==1,]))    # odds(1vs0) at given intercept value
    odds[,2] <- exp(xi_zeta0[2] + zeta_coefs%*%t(X[R==1,]))  # odds(2vs0) at given intercept value
    denom <- as.matrix(1 + rowSums(odds))                    # sum of 3 odds to be used as denominator of pr
    prob_s <- cbind(1/denom, odds[,1]/denom)                 
    return(prob_s)
  }
  goalmarg_s <- c(4/(4+2+1), 2/(4+2+1))
  roots <- multiroot(f=tosolve, start=c(-3,-2), fxname=gen_pr_s, goalmarg=goalmarg_s, atol=1e-12)$root # find root for mediator model
  prS <- cbind(gen_pr_s(roots), 1 - rowSums(gen_pr_s(roots))) # obtain probabilities for each S level using intercept solutions
  S_R <- Hmisc::rMultinom(prS,1)
  S=rep(NA,length(R))
  S[R==1]=S_R
  
  ## A
  A1=rbinom(length(S_R[S_R==1]), size=1, p=plogis(as.numeric(alpha_1%*%t(data.frame(cbind(rep(1,length(S_R[S_R==1])),X[which(S_R==1),]))))))
  A2=rbinom(length(S_R[S_R==2]), size=1, p=plogis(as.numeric(alpha_2%*%t(data.frame(cbind(rep(1,length(S_R[S_R==2])),X[which(S_R==2),]))))))
  A3=rbinom(length(S_R[S_R==3]), size=1, p=plogis(as.numeric(alpha_3%*%t(data.frame(cbind(rep(1,length(S_R[S_R==3])),X[which(S_R==3),]))))))
  A_R=rep(NA,length(S_R));A_R[S_R==1]=A1;A_R[S_R==2]=A2;A_R[S_R==3]=A3
  A=rep(NA,length(R));A[R==1]=A_R
  
  ## Y
  f1=function(x) sin(x)/5
  f2=function(x) exp(-0.25*x)
  f3=function(x) 0.02*x^2+(2*(1+0.1*x))^2+2*(0.015*x)^3
  Y1=1+5+f1(theta_0[3]*X[,2])+f1(theta_0[4]*X[,3])+f1(theta_0[5]*X[,4])+f2(theta_0[6]*X[,5])+f2(theta_0[7]*X[,6])+f2(theta_0[8]*X[,7])+f3(theta_0[9]*X[,8])+f3(theta_0[10]*X[,9])+f3(theta_0[11]*X[,10])+
    0.2*X1_1+0.4*X1_2-0.5*X1_3+0.1*X1_4-0.01*X1_5+0.2*X[,2]+0.2*X[,3]-0.2*X[,4]-0.2*X[,5]+
    rnorm(n,0,10)
  Y0=1+f1(theta_0[3]*X[,2])+f1(theta_0[4]*X[,3])+f1(theta_0[5]*X[,4])+f2(theta_0[6]*X[,5])+f2(theta_0[7]*X[,6])+f2(theta_0[8]*X[,7])+f3(theta_0[9]*X[,8])+f3(theta_0[10]*X[,9])+f3(theta_0[11]*X[,10])+
    rnorm(n,0,10)  
  Y=Y0*(1-A)+Y1*A
  Y_R=Y[R==1]
  
  return(data.frame(X,R,S,A,Y,Y1,Y0))
}


# ###########------ True value of psi_{1,1}(x_tilde):E(Y1|X1=x_tilde,S=1), and phi_{1}(x_tilde):E(Y1|X1=x_tilde,R=0)
GetTrue=function(n, n_m, x_tilde){
  mean_psi=NULL
  mean_phi=NULL
  for (i in 1:nGetTrue) {
    Data=Gen(n, n_m)
    Y_1=Data$Y1
    Y_0=Data$Y0
    mean_psi_temp=mean(Y_1[which(Data$X1==x_tilde & Data$S==1)])
    mean_psi=c(mean_psi,mean_psi_temp)
    mean_phi_temp=mean(Y_1[which(Data$X1==x_tilde & Data$R==0)])
    mean_phi=c(mean_phi,mean_phi_temp)
  }
  psi=mean(mean_psi);phi=mean(mean_phi)
  results=c(psi,phi)
  return(results)
}


EST=function(n, n_m, x_tilde){
  set.seed(i+2)
  Data=Gen(n, n_m)
  Y_R=Data$Y[Data$R==1] 
  R=Data$R
  n_internal=dim(Data[R==1,])[1]
  ##### nuisance parameters for psi_{1,1}(x_tilde):E(Y1|X1=x_tilde,S=1)
  # inverse_weight={1/n_internal sum_{i=1}^{n_internal}I(X1=x_tilde, S=1)}^(-1)
  inverse_weight=(length(which(Data[R==1,]$X1==x_tilde& Data[R==1,]$S==1))/n_internal)^(-1)
  # mu=E(Y|A=1,X, R=1)
  model_mu=gam(Y~A+as.factor(X1)+s(X2)+s(X3)+s(X4)+s(X5)+s(X6)+s(X7)+lo(X8)+lo(X9)+lo(X10)+A*as.factor(X1)+A*X2+A*X3+A*X4+A*X5,data=Data[R==1,])  
  newdata=data.frame(rep(1,n_internal),as.factor(Data[R==1,]$X1),Data[R==1,]$X2,Data[R==1,]$X3,Data[R==1,]$X4,Data[R==1,]$X5,Data[R==1,]$X6,Data[R==1,]$X7,Data[R==1,]$X8,Data[R==1,]$X9,Data[R==1,]$X10,as.factor(Data[R==1,]$X1),Data[R==1,]$X2,Data[R==1,]$X3,Data[R==1,]$X4,Data[R==1,]$X5)
  names(newdata)=c("A","X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","A1X1","A1X2","A1X3","A1X4","A1X5") 
  mu=predict.Gam(model_mu,newdata = newdata)
  
  mis_model_mu=lm(Y~A+as.factor(X1)+X2+X3+X4+X5,data=Data[R==1,])  
  newdata=data.frame(rep(1,n_internal),as.factor(Data[R==1,]$X1),Data[R==1,]$X2,Data[R==1,]$X3,Data[R==1,]$X4,Data[R==1,]$X5)
  names(newdata)=c("A","X1","X2","X3","X4","X5") 
  mis_mu=predict(mis_model_mu,newdata = newdata)
  
  # eta=Pr(A=1|X, R=1)=sum_{s=1}^{3}Pr(A=a|X, S=s, R=1)Pr(S=s|X, R=1)=model_a*model_s
  model_s=multinom(as.factor(S)~X1+X2+X3+X4+X5+X6+X7+X8+X9+X10,data=Data[R==1,],trace=F)
  s_prob=predict(model_s,newdata=Data[R==1,],"probs")
  q=s_prob[,1]
  model_a1=glm(A~as.factor(X1)+X2+X3+X4+X5+X6+X7+X8+X9+X10,family=binomial,data=Data[Data$S==1 & R==1,]) # not as.factor(S) nor as.factor(X1), a bit cheating here, but align with the data generating mechnism
  model_a2=glm(A~as.factor(X1)+X2+X3+X4+X5+X6+X7+X8+X9+X10,family=binomial,data=Data[Data$S==2 & R==1,])
  model_a3=glm(A~as.factor(X1)+X2+X3+X4+X5+X6+X7+X8+X9+X10,family=binomial,data=Data[Data$S==3 & R==1,])
  A.pre_s1=predict.glm(model_a1,newdata=Data[R==1,],type="response")
  A.pre_s2=predict.glm(model_a2,newdata=Data[R==1,],type="response")
  A.pre_s3=predict.glm(model_a3,newdata=Data[R==1,],type="response")
  eta=A.pre_s1*s_prob[,1]+A.pre_s2*s_prob[,2]+A.pre_s3*s_prob[,3]
  
  mis_model_s=multinom(as.factor(S)~X1+X2+X3+X4+X5,data=Data[R==1,],trace=F)
  mis_s_prob=predict(mis_model_s,newdata=Data[R==1,],"probs")
  mis_q=mis_s_prob[,1]
  mis_model_a1=glm(A~as.factor(X1)+X2+X3+X4+X5,family=binomial,data=Data[Data$S==1 & R==1,]) # not as.factor(S) nor as.factor(X1), a bit cheating here, but align with the data generating mechnism
  mis_model_a2=glm(A~as.factor(X1)+X2+X3+X4+X5,family=binomial,data=Data[Data$S==2 & R==1,])
  mis_model_a3=glm(A~as.factor(X1)+X2+X3+X4+X5,family=binomial,data=Data[Data$S==3 & R==1,])
  mis_A.pre_s1=predict.glm(mis_model_a1,newdata=Data[R==1,],type="response")
  mis_A.pre_s2=predict.glm(mis_model_a2,newdata=Data[R==1,],type="response")
  mis_A.pre_s3=predict.glm(mis_model_a3,newdata=Data[R==1,],type="response")
  mis_eta=mis_A.pre_s1*mis_s_prob[,1]+mis_A.pre_s2*mis_s_prob[,2]+mis_A.pre_s3*mis_s_prob[,3]
  ##### estimation
  G_comp_v=mean(mu[which(Data[R==1,]$X1==x_tilde& Data[R==1,]$S==1)])
  G_comp_x=mean(mis_mu[which(Data[R==1,]$X1==x_tilde& Data[R==1,]$S==1)])
  IPTW_core_v=q/eta*(Y_R)
  IPTW_v=inverse_weight/n_internal*(sum(IPTW_core_v[which(Data[R==1,]$X1==x_tilde& Data[R==1,]$A==1)]))
  IPTW_core_x=mis_q/mis_eta*(Y_R)
  IPTW_x=inverse_weight/n_internal*(sum(IPTW_core_x[which(Data[R==1,]$X1==x_tilde& Data[R==1,]$A==1)]))
  second_piece_muv_qv=q/eta*(Y_R-mu)
  second_piece_muv_qx=mis_q/mis_eta*(Y_R-mu)
  second_piece_mux_qv=q/eta*(Y_R-mis_mu)
  second_piece_mux_qx=mis_q/mis_eta*(Y_R-mis_mu)
  est_psi_muv_qv=inverse_weight/n_internal*(sum(mu[which(Data[R==1,]$X1==x_tilde& Data[R==1,]$S==1)])+sum(second_piece_muv_qv[which(Data[R==1,]$X1==x_tilde& Data[R==1,]$A==1)]))
  est_psi_muv_qx=inverse_weight/n_internal*(sum(mu[which(Data[R==1,]$X1==x_tilde& Data[R==1,]$S==1)])+sum(second_piece_muv_qx[which(Data[R==1,]$X1==x_tilde& Data[R==1,]$A==1)]))
  est_psi_mux_qv=inverse_weight/n_internal*(sum(mis_mu[which(Data[R==1,]$X1==x_tilde& Data[R==1,]$S==1)])+sum(second_piece_mux_qv[which(Data[R==1,]$X1==x_tilde& Data[R==1,]$A==1)]))
  est_psi_mux_qx=inverse_weight/n_internal*(sum(mis_mu[which(Data[R==1,]$X1==x_tilde& Data[R==1,]$S==1)])+sum(second_piece_mux_qx[which(Data[R==1,]$X1==x_tilde& Data[R==1,]$A==1)]))
  ##### Results
  results=c(est_psi_muv_qv,G_comp_v,IPTW_v,
            est_psi_muv_qx,G_comp_v,IPTW_x,
            est_psi_mux_qv,G_comp_x,IPTW_v,
            est_psi_mux_qx,G_comp_x,IPTW_x)
  return(results)
}

###########------- get the plot for one sample size
n=10000
#n=100000
n_m=1000
# n_m=2000 
# n_m=5000

true3=GetTrue(n,n_m,3)
est=NULL
for (i in 1:nsim) {
  temp=EST(n, n_m, 3)
  est=rbind(est,temp)
  }
  
bias_mu_q_eta=colMeans(est[,c(1:3)])-true3[1] # bias of DR, G_comp, IPTW
sd_mu_q_eta=apply(est[,c(1:3)],2,sd) # Monte-Carlo sd of DR, G_comp, IPTW

bias_mu=colMeans(est[,c(4:6)])-true3[1] # bias of DR, G_comp, IPTW
sd_mu=apply(est[,c(4:6)],2,sd) # Monte-Carlo sd of DR, G_comp, IPTW

bias_q_eta=colMeans(est[,c(7:9)])-true3[1] # bias of DR, G_comp, IPTW
sd_q_eta=apply(est[,c(7:9)],2,sd) # Monte-Carlo sd of DR, G_comp, IPTW

bias_wrong=colMeans(est[,c(10:12)])-true3[1] # bias of DR, G_comp, IPTW
sd_wrong=apply(est[,c(10:12)],2,sd) # Monte-Carlo sd of DR, G_comp, IPTW

#### plots
plot( c(1,4), las = 2, xlim =c(0.6, 4.4), ylim = c(-1.6, 1.6),  type="n",
      xlab=TeX(r'(Correct Model(s))',bold=TRUE), ylab=TeX(r'(Bias$\pm$SD)', bold=TRUE), 
      main="Comparison of different model performance, subgroup=3, n_m=1000", xaxt="n")
axis(1, at=1:4, labels=c(TeX(r'($(\mu, \eta, q)$)', bold=FALSE),TeX(r'($(\mu)$)', bold=FALSE),TeX(r'($(\eta, q)$)', bold=FALSE),TeX(r'(None)', bold=FALSE)) )
for (i in 1:3){
  points(0.8+0.1*i,bias_mu_q_eta[i],pch=7+i)
  segments(0.8+0.1*i, bias_mu_q_eta[i]-sd_mu_q_eta[i], 0.8+0.1*i, bias_mu_q_eta[i]+sd_mu_q_eta[i], lwd = 2 )
}
for (i in 1:3){
  points(1.8+0.1*i,bias_mu[i],pch=7+i)
  segments(1.8+0.1*i, bias_mu[i]-sd_mu[i], 1.8+0.1*i, bias_mu[i]+sd_mu[i], lwd = 2 )
}
for (i in 1:3){
  points(2.8+0.1*i,bias_q_eta[i],pch=7+i)
  segments(2.8+0.1*i, bias_q_eta[i]-sd_q_eta[i], 2.8+0.1*i, bias_q_eta[i]+sd_q_eta[i], lwd = 2 )
}
for (i in 1:3){
  points(3.8+0.1*i,bias_wrong[i],pch=7+i)
  segments(3.8+0.1*i, bias_wrong[i]-sd_wrong[i], 3.8+0.1*i, bias_wrong[i]+sd_wrong[i], lwd = 2 )
}
abline(h=0)

legend(0.5, -1, c('Doubly robust', 'Regression', 'IPTW'),  horiz = F, bty = 'n', cex=1.2,pch=c(8,9,10))

################ change sample size, additional simulation in the appendix
SIM=function(n,n_m){
  true3=GetTrue(n,n_m,3)
  est=NULL
  for (i in 1:nsim) {
    temp=EST(n, n_m, 3)
    est=rbind(est,temp)
  }
  bias_mu_q_eta=colMeans(est[,c(1:3)])-true3[1] # bias of DR, G_comp, IPTW
  sd_mu_q_eta=apply(est[,c(1:3)],2,sd) # Monte-Carlo sd of DR, G_comp, IPTW
  
  bias_mu=colMeans(est[,c(4:6)])-true3[1] # bias of DR, G_comp, IPTW
  sd_mu=apply(est[,c(4:6)],2,sd) # Monte-Carlo sd of DR, G_comp, IPTW
  
  bias_q_eta=colMeans(est[,c(7:9)])-true3[1] # bias of DR, G_comp, IPTW
  sd_q_eta=apply(est[,c(7:9)],2,sd) # Monte-Carlo sd of DR, G_comp, IPTW
  
  bias_wrong=colMeans(est[,c(10:12)])-true3[1] # bias of DR, G_comp, IPTW
  sd_wrong=apply(est[,c(10:12)],2,sd) # Monte-Carlo sd of DR, G_comp, IPTW
  
  return(round(rbind(cbind(bias_mu_q_eta,sd_mu_q_eta),cbind(bias_mu,sd_mu),cbind(bias_q_eta,sd_q_eta),cbind(bias_wrong,sd_wrong)),2))
}

results=NULL
for (n in c(10000,100000)) {
  for (n_m in c(1000,2000,5000)) {
    result=SIM(n,n_m)
    results=cbind(result,results)
  }
}
results
